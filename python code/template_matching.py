# -*- coding: utf-8 -*-
"""Template_matching.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q9DKDdTTAAZUiz6gze_sDmFrfscpa5mq

#Import library
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as img
from PIL import Image, ImageDraw
import math
import datetime
import pandas as pd
import os
from google.colab.patches import cv2_imshow

"""#Read the template



"""

# Read template
temp_cir = cv2.imread('/content/drive/MyDrive/Matching/pattern/Template_circle.bmp') 
temp_cro = cv2.imread('/content/drive/MyDrive/Matching/pattern/Template_cross.bmp') 
temp_border_cir = cv2.imread('/content/drive/MyDrive/Matching/pattern/Template_BorderCircle.bmp') 
temp_border_cro = cv2.imread('/content/drive/MyDrive/Matching/pattern/Template_BorderCross.bmp')

"""#Part1 : Non-pyramid

## NCC
"""

# Normalized Cross Correlation
def NCC(src,temp):
  ht = temp.shape[0]
  wt = temp.shape[1]
  src = src - np.sum(src)/(ht*wt)
  cor = np.sum(src*temp)
  norm = np.sqrt(np.sum(src**2))*np.sqrt(np.sum(temp**2))
  ncc = cor / norm
  return ncc

"""##Template matching"""

def template_matching(src,temp):
  
  # Get image shape
  hs = src.shape[0]
  ws = src.shape[1]

  ht = temp.shape[0]
  wt = temp.shape[1]
   
  #Initial setting
  [best_Y,best_X] = [0,0]
  best_ncc = 0
  src = np.array(src, dtype="int")
  temp = np.array(temp, dtype="int")
  temp = temp - np.sum(temp)/(ht*wt)
  # Store the NCC score of matching
  score = np.zeros((hs-ht+1,ws-wt+1))
  # Scan
  for y in range(0, hs-ht+1):
      for x in range(0, ws-wt+1):
          # Calculate normalized correlation coefficient (NCC)
          source = src[y:y+ht,x:x+wt]
          score[y,x] = NCC(source,temp)
          # Find the highest score
          if score[y,x] > best_ncc :
            best_ncc = score[y,x]
            [best_Y,best_X] = [y,x]

  return [best_X,best_Y]

"""##Check best match coordinate"""

def coordinate(src,temp) :
  
  #Calculating coordinates
  top_left = template_matching(src,temp)
  top_right = [top_left[0]+temp.shape[1]-1,top_left[1]]
  bottom_left = [top_left[0],top_left[1]+temp.shape[0]-1]
  bottom_right = [bottom_left[0]+temp.shape[1]-1,bottom_left[1]]
  return [top_left,top_right,bottom_left,bottom_right]

"""##Draw position

**Circle**
"""

def draw_circle(src,temp,temp_border,draw) :

  # Best match coordinate for pattern
  co = coordinate(src,temp)
  # Best match coordinate for border
  co_bo = coordinate(src,temp_border)

  # Template shape
  h = temp.shape[0]
  # Template border shape
  hb = temp_border.shape[0]
  
  # Draw pattern location
  center_coordinates = (int((co[0][0]+co[1][0])/2) , int((co[0][1]+co[2][1])/2))
  radius = int(h/2)
  color = (0,255,0) # Green in RGB (using plt)
  thickness = 3
  circle = cv2.circle(draw, center_coordinates, radius, color, thickness) # Circle
  
  plt.plot([co[0][0],co[1][0]], [co[0][1]+h/2,co[1][1]+h/2],
          color="green",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co[0][0]+h/2,co[2][0]+h/2],[co[0][1],co[2][1]],
          color='green',linestyle="--", linewidth=1) # Vertical dash line

  # Draw border location
  left_up = (int(co_bo[0][0]), int(co_bo[0][1]))
  right_down = (int(co_bo[3][0]), int(co_bo[3][1]))
  color = (0, 0, 255) # Blue in RGB (using plt)
  thickness = 3
  cv2.rectangle(draw, left_up, right_down, color, thickness) 

  plt.plot([co_bo[0][0],co_bo[1][0]], [co_bo[0][1]+hb/2,co_bo[1][1]+hb/2],
          color="blue",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co_bo[0][0]+hb/2,co_bo[2][0]+hb/2],[co_bo[0][1],co_bo[2][1]],
          color='blue',linestyle="--", linewidth=1) # Vertical dash line

  plt.imshow(draw)
  plt.savefig('/content/drive/MyDrive/Matching/match_circle/example.png')
  plt.show()

  return [co, co_bo]

"""**Cross**"""

def draw_cross(src,temp,temp_border,draw) :

  # Best match coordinate for pattern
  co = coordinate(src,temp)
  # Best match coordinate for border
  co_bo = coordinate(src,temp_border)

  # Template shape
  h = temp.shape[0]
  # Template border shape
  hb = temp_border.shape[0]
  
  # Draw pattern location
  left_up_p = (int(co[0][0]), int(co[0][1]))
  right_down_p = (int(co[3][0]), int(co[3][1]))
  color_p = (0, 255, 0) # Green in RGB (using plt)
  thickness_p = 3
  cv2.rectangle(draw, left_up_p, right_down_p, color_p, thickness_p) 
  
  plt.plot([co[0][0],co[1][0]], [co[0][1]+h/2,co[1][1]+h/2],
          color="green",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co[0][0]+h/2,co[2][0]+h/2],[co[0][1],co[2][1]],
          color='green',linestyle="--", linewidth=1) # Vertical dash line

  # Draw border location
  left_up = (int(co_bo[0][0]), int(co_bo[0][1]))
  right_down = (int(co_bo[3][0]), int(co_bo[3][1]))
  color = (0, 0, 255) # Blue in RGB (using plt)
  thickness = 3
  cv2.rectangle(draw, left_up, right_down, color, thickness) 

  plt.plot([co_bo[0][0],co_bo[1][0]], [co_bo[0][1]+hb/2,co_bo[1][1]+hb/2],
          color="blue",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co_bo[0][0]+hb/2,co_bo[2][0]+hb/2],[co_bo[0][1],co_bo[2][1]],
          color='blue',linestyle="--", linewidth=1) # Vertical dash line

  plt.imshow(draw)
  plt.savefig('/content/drive/MyDrive/Matching/match_cross/example.png')
  plt.show()

  return [co, co_bo]

"""##Combine all steps
Template matching and calculate the center position difference

**Circle**
"""

# Circle
def cir_match(src,temp,temp_border,draw):
  circle = draw_circle(src,temp,temp_border,draw)
  
  pattern = circle[0]
  border = circle[1]

  px = (pattern[0][0]+pattern[1][0])/2
  bx = (border[0][0]+border[1][0])/2
  py = (pattern[0][1]+pattern[2][1])/2
  by = (border[0][1]+border[2][1])/2

  distance = math.sqrt(pow((px-bx),2)+pow((py-by),2))
  print("Center position difference : ",distance)
  
  return distance

"""**Cross**"""

# Cross
def cro_match(src,temp,temp_border,draw):
  cross = draw_cross(src,temp,temp_border,draw)
  
  pattern = cross[0]
  border = cross[1]

  px = (pattern[0][0]+pattern[1][0])/2
  bx = (border[0][0]+border[1][0])/2
  py = (pattern[0][1]+pattern[2][1])/2
  by = (border[0][1]+border[2][1])/2

  distance = math.sqrt(pow((px-bx),2)+pow((py-by),2))
  print("Center position difference : ",distance)
  
  return distance

"""##Result

**Circle**

1. Whole folder
"""

run_time = []
cir_name = []
cir_dis = []
for p in range(1,5):
  for c in range(1,5):
    # Read source
    circle_ori = cv2.imread('/content/drive/MyDrive/Matching/circle/Panel{0}_circle{1}.bmp'.format(p,c))
    blurred = cv2.medianBlur(circle_ori,9)
    start = datetime.datetime.now()
    # Template matching
    circle = cir_match(blurred,temp_cir,temp_border_cir,circle_ori)
    end = datetime.datetime.now()
    
    # Record run time
    rt = end - start
    run_time.append(rt)
    
    # Save result picture
    example = cv2.imread('/content/drive/MyDrive/Matching/match_circle/example.png')
    cv2.imwrite('/content/drive/MyDrive/Matching/match_circle/P{0}_circle{1}.png'.format(p,c),example)
    os.remove('/content/drive/MyDrive/Matching/match_circle/example.png')

    # Save each center position difference
    cir_dis.append(circle)
    cir_name.append('Panel{0}_circle{1}'.format(p,c))

run_time_avg = pd.Series(run_time).mean()
print('Average run time : ',run_time_avg)
dis_rec = pd.DataFrame(cir_dis, index = cir_name,columns = ['Distance'])
print(dis_rec.T)

run_time_avg

dis_rec

dis_rec.to_csv('/content/drive/MyDrive/Matching/match_circle/match_circle_dis.csv')

"""2. Single image ( Deal with the mistake : Panel2_circle2 -> Wrong matching )

* Solution : Apply power law transform with gamma = 0.4
* Modify the distance record 
    


"""

# Read source
circle_ori = cv2.imread('/content/drive/MyDrive/Matching/circle/Panel2_circle2.bmp')
# Power law transform with gamma = 0.4
powerlaw = np.array(255*(circle_ori/255)**0.4,dtype='uint8')
#cv2_imshow(powerlaw)

# Template matching
circle = cir_match(powerlaw,temp_cir,temp_border_cir,circle_ori)

# Save result picture
example = cv2.imread('/content/drive/MyDrive/Matching/match_circle/example.png')
cv2.imwrite('/content/drive/MyDrive/Matching/match_circle/P2_circle2.png',example)
os.remove('/content/drive/MyDrive/Matching/match_circle/example.png')

# Modify the distance record
data = '/content/drive/MyDrive/Matching/match_circle/match_circle_dis.csv'
df_cir_dis = pd.read_csv(data)
df_cir_dis = df_cir_dis.rename(columns={'Unnamed: 0':'Image'})
df_cir_dis.iloc[5,1] = circle
dis_cir = list(df_cir_dis.iloc[:,1])
dis_cir_name = list(df_cir_dis.iloc[:,0])
dis_rec_cir = pd.DataFrame(dis_cir, index = dis_cir_name,columns = ['Distance'])
dis_rec_cir

dis_rec_cir.to_csv('/content/drive/MyDrive/Matching/match_circle/match_circle_dis.csv')

"""**Cross**

1. Whole folder
"""

run_time_cro = []
cro_name = []
cro_dis = []
for p in range(1,5):
  for c in range(1,5):
    # Read source
    cross_ori = cv2.imread('/content/drive/MyDrive/Matching/cross/Panel{0}_cross{1}.bmp'.format(p,c))
    blurred_cro = cv2.medianBlur(cross_ori,9)
    start = datetime.datetime.now()
    # Template matching
    cross = cro_match(blurred_cro,temp_cro,temp_border_cro,cross_ori)
    end = datetime.datetime.now()
    
    # Record run time
    rt = end - start
    run_time_cro.append(rt)
    
    # Save result picture
    example = cv2.imread('/content/drive/MyDrive/Matching/match_cross/example.png')
    cv2.imwrite('/content/drive/MyDrive/Matching/match_cross/P{0}_cross{1}.png'.format(p,c),example)
    os.remove('/content/drive/MyDrive/Matching/match_cross/example.png')

    # Save each center position difference
    cro_dis.append(cross)
    cro_name.append('Panel{0}_cross{1}'.format(p,c))

run_time_avg_cro = pd.Series(run_time_cro).mean()
print('Average run time : ',run_time_avg_cro)
dis_rec_cro = pd.DataFrame(cro_dis, index = cro_name,columns = ['Distance'])
print(dis_rec_cro.T)

run_time_avg_cro

dis_rec_cro

dis_rec_cro.to_csv('/content/drive/MyDrive/Matching/match_cross/match_cross_dis.csv')

"""2. Single image"""

# Read source
cross_ori = cv2.imread('/content/drive/MyDrive/Matching/cross/Panel1_cross2.bmp')
# Apply a "median" blur to the image
blurred_cro = cv2.medianBlur(cross_ori,9)
# Template matching
cross = cro_match(blurred_cro,temp_cro,temp_border_cro,cross_ori)

"""# Part2 : Pyramid

##Build pyramid
"""

def build_pyramid(src, maxleval):
  pyramid = [src]
  for i in range(0,maxleval):
      src = cv2.pyrDown(src)
      pyramid.append(src)

  pyramid.reverse()
  return pyramid

def template_match_pyramid(src,temp,maxleval):
  results = []
  ## Build image pyramid
  src_p = build_pyramid(src,maxleval)
  temp_p = build_pyramid(temp,maxleval)

  ## Template match
  for idx in range(0, maxleval+1):
      src_p2 = src_p[idx]
      temp_p2 = temp_p[idx]

      if idx == 0:
          result = cv2.matchTemplate(src_p2, temp_p2, cv2.TM_CCOEFF_NORMED)
      else:
          mask = cv2.pyrUp(thresh)
          mask8u = cv2.inRange(mask, 0, 255)
          contours = cv2.findContours(mask8u, cv2.RETR_EXTERNAL,  cv2.CHAIN_APPROX_NONE)[-2]

          tH, tW = temp_p2.shape[:2]
          for cnt in contours:
              x, y, w, h = cv2.boundingRect(cnt)
              src = src_p2[y:y+h+tH, x:x+w+tW]
              result = cv2.matchTemplate(src, temp_p2, cv2.TM_CCOEFF_NORMED)

      T,thresh = cv2.threshold(result, 0.30, 1, cv2.THRESH_TOZERO)
      results.append(thresh)

  return thresh

"""##Template matching"""

def template_match_p(src,temp,border,maxleval=10):
  result = template_match_pyramid(src,temp,maxleval)
  result2 = template_match_pyramid(src,border,maxleval)
  
  # Find best match coordinate
  minval, maxval, minloc, maxloc = cv2.minMaxLoc(result)
  if maxval > 0:
    best_co_cir = maxloc
  minval2, maxval2, minloc2, maxloc2 = cv2.minMaxLoc(result2)
  if maxval2 > 0:
    best_co_bor = maxloc2
    
  return [best_co_cir,best_co_bor]

"""##Draw position

**Circle**
"""

def draw_cir_p(src,temp,temp_border,draw):
  
  # Template shape
  h = temp.shape[0]
  w = temp.shape[1]
  # Template border shape
  hb = temp_border.shape[0]
  wb = temp_border.shape[1]

  # Best match coordinate for pattern
  tm = template_match_p(src,temp,temp_border,maxleval=10)
  top_left = tm[0]
  top_right = [top_left[0]+w-1,top_left[1]]
  bottom_left = [top_left[0],top_left[1]+h-1]
  bottom_right = [bottom_left[0]+w-1,bottom_left[1]]
  co = [top_left,top_right,bottom_left,bottom_right]
  # Best match coordinate for border
  top_left_b = tm[1]
  top_right_b = [top_left_b[0]+wb-1,top_left_b[1]]
  bottom_left_b = [top_left_b[0],top_left_b[1]+hb-1]
  bottom_right_b = [bottom_left_b[0]+wb-1,bottom_left_b[1]]
  co_bo = [top_left_b,top_right_b,bottom_left_b,bottom_right_b]

  # Draw pattern location
  center_coordinates = (int((co[0][0]+co[1][0])/2) , int((co[0][1]+co[2][1])/2))
  radius = int(h/2)
  color = (0,255,0) # Green in RGB (using plt)
  thickness = 3
  circle = cv2.circle(draw, center_coordinates, radius, color, thickness) # Circle
    
  plt.plot([co[0][0],co[1][0]], [co[0][1]+h/2,co[1][1]+h/2],
          color="green",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co[0][0]+h/2,co[2][0]+h/2],[co[0][1],co[2][1]],
          color='green',linestyle="--", linewidth=1) # Vertical dash line

  # Draw border location
  left_up = (int(co_bo[0][0]), int(co_bo[0][1]))
  right_down = (int(co_bo[3][0]), int(co_bo[3][1]))
  color = (0, 0, 255) # Blue in RGB (using plt)
  thickness = 3
  cv2.rectangle(draw, left_up, right_down, color, thickness) 

  plt.plot([co_bo[0][0],co_bo[1][0]], [co_bo[0][1]+hb/2,co_bo[1][1]+hb/2],
            color="blue",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co_bo[0][0]+hb/2,co_bo[2][0]+hb/2],[co_bo[0][1],co_bo[2][1]],
            color='blue',linestyle="--", linewidth=1) # Vertical dash line

  plt.imshow(draw)
  plt.savefig('/content/drive/MyDrive/Matching/match_circle_p/example.png')
  plt.show()

  return [co, co_bo]

"""**Cross**"""

def draw_cro_p(src,temp,temp_border,draw):
  
  # Template shape
  h = temp.shape[0]
  w = temp.shape[1]
  # Template border shape
  hb = temp_border.shape[0]
  wb = temp_border.shape[1]

  # Best match coordinate for pattern
  tm = template_match_p(src,temp,temp_border,maxleval=10)
  top_left = tm[0]
  top_right = [top_left[0]+w-1,top_left[1]]
  bottom_left = [top_left[0],top_left[1]+h-1]
  bottom_right = [bottom_left[0]+w-1,bottom_left[1]]
  co = [top_left,top_right,bottom_left,bottom_right]
  # Best match coordinate for border
  top_left_b = tm[1]
  top_right_b = [top_left_b[0]+wb-1,top_left_b[1]]
  bottom_left_b = [top_left_b[0],top_left_b[1]+hb-1]
  bottom_right_b = [bottom_left_b[0]+wb-1,bottom_left_b[1]]
  co_bo = [top_left_b,top_right_b,bottom_left_b,bottom_right_b]

  # Draw pattern location
  left_up_p = (int(co[0][0]), int(co[0][1]))
  right_down_p = (int(co[3][0]), int(co[3][1]))
  color_p = (0, 255, 0) # Green in RGB (using plt)
  thickness_p = 3
  cv2.rectangle(draw, left_up_p, right_down_p, color_p, thickness_p) 
  
  plt.plot([co[0][0],co[1][0]], [co[0][1]+h/2,co[1][1]+h/2],
          color="green",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co[0][0]+h/2,co[2][0]+h/2],[co[0][1],co[2][1]],
          color='green',linestyle="--", linewidth=1) # Vertical dash line

  # Draw border location
  left_up = (int(co_bo[0][0]), int(co_bo[0][1]))
  right_down = (int(co_bo[3][0]), int(co_bo[3][1]))
  color = (0, 0, 255) # Blue in RGB (using plt)
  thickness = 3
  cv2.rectangle(draw, left_up, right_down, color, thickness) 

  plt.plot([co_bo[0][0],co_bo[1][0]], [co_bo[0][1]+hb/2,co_bo[1][1]+hb/2],
          color="blue",linestyle="--", linewidth=1) # Horizontal dash line
  plt.plot([co_bo[0][0]+hb/2,co_bo[2][0]+hb/2],[co_bo[0][1],co_bo[2][1]],
          color='blue',linestyle="--", linewidth=1) # Vertical dash line

  plt.imshow(draw)
  plt.savefig('/content/drive/MyDrive/Matching/match_cross_p/example.png')
  plt.show()

  return [co, co_bo]

"""##Combine all step
Template matching and calculate the center position difference

**Circle**
"""

# Circle
def cir_match_p(src,temp,temp_border,draw):
  circle = draw_cir_p(src,temp,temp_border,draw)
  
  pattern = circle[0]
  border = circle[1]

  px = (pattern[0][0]+pattern[1][0])/2
  bx = (border[0][0]+border[1][0])/2
  py = (pattern[0][1]+pattern[2][1])/2
  by = (border[0][1]+border[2][1])/2

  distance = math.sqrt(pow((px-bx),2)+pow((py-by),2))
  print("Center position difference : ",distance)
  
  return distance

"""**Cross**"""

# Cross
def cro_match_p(src,temp,temp_border,draw):
  cross = draw_cro_p(src,temp,temp_border,draw)
  
  pattern = cross[0]
  border = cross[1]

  px = (pattern[0][0]+pattern[1][0])/2
  bx = (border[0][0]+border[1][0])/2
  py = (pattern[0][1]+pattern[2][1])/2
  by = (border[0][1]+border[2][1])/2

  distance = math.sqrt(pow((px-bx),2)+pow((py-by),2))
  print("Center position difference : ",distance)
  
  return distance

"""##Result

**Circle**
"""

run_time_p = []
cir_name_p = []
cir_dis_p = []
for p in range(1,5):
  for c in range(1,5):
    # Read source
    circle_ori = cv2.imread('/content/drive/MyDrive/Matching/circle/Panel{0}_circle{1}.bmp'.format(p,c))
    blurred = cv2.medianBlur(circle_ori,9)
    start = datetime.datetime.now()
    # Template matching
    circle = cir_match_p(blurred,temp_cir,temp_border_cir,circle_ori)
    end = datetime.datetime.now()
    
    # Record run time
    rt = end - start
    run_time_p.append(rt)
    
    # Save result picture
    example = cv2.imread('/content/drive/MyDrive/Matching/match_circle_p/example.png')
    cv2.imwrite('/content/drive/MyDrive/Matching/match_circle_p/P{0}_circle{1}.png'.format(p,c),example)
    os.remove('/content/drive/MyDrive/Matching/match_circle_p/example.png')

    # Save each center position difference
    cir_dis_p.append(circle)
    cir_name_p.append('Panel{0}_circle{1}'.format(p,c))

run_time_avg_p = pd.Series(run_time_p).mean()
print('Average run time : ',run_time_avg_p)
dis_rec_p = pd.DataFrame(cir_dis_p, index = cir_name_p,columns = ['Distance'])
print(dis_rec_p.T)

run_time_avg_p

dis_rec_p

dis_rec_p.to_csv('/content/drive/MyDrive/Matching/match_circle_p/circle_pyramid_dis.csv')

"""**Cross**"""

run_time_cro_p = []
cro_name_p = []
cro_dis_p = []
for p in range(1,5):
  for c in range(1,5):
    # Read source
    cross_ori = cv2.imread('/content/drive/MyDrive/Matching/cross/Panel{0}_cross{1}.bmp'.format(p,c))
    blurred_cro = cv2.medianBlur(cross_ori,9)
    start = datetime.datetime.now()
    # Template matching
    cross = cro_match_p(blurred_cro,temp_cro,temp_border_cro,cross_ori)
    end = datetime.datetime.now()
    
    # Record run time
    rt = end - start
    run_time_cro_p.append(rt)
    
    # Save result picture
    example = cv2.imread('/content/drive/MyDrive/Matching/match_cross_p/example.png')
    cv2.imwrite('/content/drive/MyDrive/Matching/match_cross_p/P{0}_cross{1}.png'.format(p,c),example)
    os.remove('/content/drive/MyDrive/Matching/match_cross_p/example.png')

    # Save each center position difference
    cro_dis_p.append(cross)
    cro_name_p.append('Panel{0}_cross{1}'.format(p,c))

run_time_avg_cro_p = pd.Series(run_time_cro_p).mean()
print('Average run time : ',run_time_avg_cro_p)
dis_rec_cro_p = pd.DataFrame(cro_dis_p, index = cro_name_p,columns = ['Distance'])
print(dis_rec_cro_p.T)

run_time_avg_cro_p

dis_rec_cro_p

"""**Deal with mistake** 
**( Panel2_cross1 -> Wrong matching )**

1. Solution : Change median filter mask from 9 to 15
2. Modify the distance record
"""

# Read source
cross_ori = cv2.imread('/content/drive/MyDrive/Matching/cross/Panel2_cross1.bmp')

# Change median blur mask from 9 to 15
blurred_cro = cv2.medianBlur(cross_ori,15)

# Template matching
cross = cro_match_p(blurred_cro,temp_cro,temp_border_cro,cross_ori)

# Save result picture
example = cv2.imread('/content/drive/MyDrive/Matching/match_cross_p/example.png')
cv2.imwrite('/content/drive/MyDrive/Matching/match_cross_p/P2_cross1.png',example)
os.remove('/content/drive/MyDrive/Matching/match_cross_p/example.png')

# Modify the distance record
dis_rec_cro_p.iloc[4,0] = cross
dis_rec_cro_p

dis_rec_cro_p.to_csv('/content/drive/MyDrive/Matching/match_cross_p/cross_pyramid_dis.csv')